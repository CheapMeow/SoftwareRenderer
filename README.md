# SoftwareRenderer

## 画线

Bresenham 画线算法

## 视口裁剪

三角形经过投影变换之后，三角形的部分可能在视口外

此时要裁剪掉看不到的部分。不能直接丢弃这个三角形，因为这个三角形本身也有要渲染的部分。

而是先传入这个三角形到片元着色阶段（函数），然后在片元着色里面，查看这个像素点的 UV 是不是超出屏幕了，超出则丢弃这个像素。

## 背面剔除

获取世界空间（经过视口变换之后）中的三角形的法向方向，与视线方向点积，如果结果小于 0 则绘制

## 视锥剔除

为每一个物体创建一个 boundingbox

经过投影变换之后，如果这个物体的 boundingbox 不在裁剪空间里面，就把整个物体丢掉

## 管理器

Scene 类是摄像机和物体的容器，执行物体层级的视锥体裁剪，来确定哪些物体将会被提交到 RenderManager 的队列

+ 物体层级的视锥体裁剪是判断 boundingbox 六个点是否在视锥体内

SceneManager 负责场景的加载和切换

RenderManager 负责处理渲染队列

SoftwareRenderer 负责渲染单位物体，执行屏幕裁剪，调用顶点着色，执行透视除法，调用 Rasterizer 渲染图元

+ 屏幕裁剪就是判断三角形是不是三个点都在 NDC 空间或者说裁剪空间之外，感觉也可以是称为三角形层面的视锥剔除

Rasterizer 负责渲染图元。丢弃很小的图元，遍历图元的每一个像素点，进行深度测试，然后对遍历到的图元元素进行片元着色，着色写入颜色缓冲之后更新深度缓冲

+ 遍历图元只是遍历三角形的 boundingbox 内的每个像素点，三角形顶点到像素点的向量和三角形的边向量做叉乘

    都是同一个方向，说明点在三角形内，那么就可以填充

    这就就完成了在一个 bbox 内填充一个三角形

+ 片元着色器中，使用重心坐标对顶点上的物理量进行插值

    重心坐标的计算决定了它的使用

    假设三角形三个顶点为 A、B、C

    重心坐标的计算是 AP x AB、BP x BC、CP x CA

    所以这种算法下第 0 个重心坐标对应第 2 个顶点的系数，第 1 个重心坐标对应第 0 个顶点的系数，第 2 个重心坐标对应第 1 个顶点的系数

    最好是把重心坐标的这个顺序轮换一下，使得它能够和别人自然地点积 

+ 可以在片元中计算重心坐标，也可以在传入片元函数之前就计算好每个像素点的重心坐标，然后传入

    当然，还可以在遍历图元的过程中，不是遍历整数的像素坐标，而是先计算起始的像素坐标对应的重心坐标，然后遍历重心坐标，坐标的增量是单位重心坐标向量，也就是三角形的边向量/三角形的面积

最后交换颜色缓冲

## 着色器

说实话我不知道为什么他在 Phong shading 中要把法线先乘以 MV^{-1}^T，为什么传入的 vertex 是 viewDir

